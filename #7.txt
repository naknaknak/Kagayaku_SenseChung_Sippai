#7
15장 함수2
-오버로딩
 이름이 같은 함수지만 다른 매개변수를 받는다면 같이 쓸 수 있다. 이 때 매개변수가 같고 리턴 타입이 다른 함수는 쓸 수 없다. 내부적으로는 함수 매개변수에 따라 컴파일러가 함수마다 다른 이름을 붙인다. 리턴 타입만 다른 함수를 쓸 수 없는 이유는 어떤 함수를 썼을 때 그 함수가 둘 중 무슨 함수인지 확실히 알 수 없기 때문이다. 이 규칙에 반하는 코드(레퍼런스를 사용한다거나) 는 문법오류가 난다.
ex) 
int max(int a,int b)
float max(float a,float b)가능
int max(float a,float b)불가능
컴퓨터도 암시적으로 함수를 선택하는데. 규칙에 대해선 책을 보자.
float max(float a,float b) 에서 a,b에 int값을 넣어도 이 함수밖에 없다면 이 함수가 호출될 것이다. 이는 int->float이 암시적으로 형변환이 되기 때문에 적용할 수 있다. 물론 정확히 맞는 타입을 넣는 것이 제일 좋으므로 굳이 길게 쓰지는 않겠다.
-디폴트 인자
 함수 인자값을 안 넣으면 미리 정해놓은 값이 들어온 걸로 처리한다.  
int max(int a=0,int b=1)이런식으로 쓴다. 뒤부터 써야 한다(이 경우에는 a만 디폴트로 넣으면 안된다. 그리고 사용시에는 max(1);(a값이 1이 됨) or max();같은 식으로 앞부터 들어간다. 
오버로딩과 디폴트 인자가 충돌할 수도 있는데 이런 경우는 문법적으로 허용하지 않는다.
-재귀 호출(recursion)
int pivonacci(int n)
{
	if(n <=1) return 1;
	else if(n==2) return 2;
	else return pivonacci(n-1)+pivonacci(n-2);
}
가장 자주 나오는 게 피보나치 수열이다. 이렇게 함수가 자기 자신을 호출하는 걸 재귀 호출이라 한다. 함수 호출 시에 리턴 주소, 리턴값, 함수 인자를 스택에 넣는데, 이렇게 쭉 무한대로 호출하면 스택이 터진다. 그래서 보통 base case라는 끝나는 부분부터 생각해서 짜는 것이 좋다.
하노이의 탑.
-재귀호출을 어디에 쓰냐!
 같은 작업을 하면서 작업을 나눌 때. QuickSort,MergeSort같은 정렬 알고리즘에서도 쓴다. 트리 탐색할 때도 쓴다. 
-함수 포인터
 코드는 책을 보시라. p377
형식은 함수 형식에 따라서 달라지는데, 위 max함수를 함수 포인터로 만든다면
int (*p)(int, int) 요렇게 만들고 p=&max;이렇게 넣으면 된다. 
typedef를 써서 어떤 프로토타입을 갖는 함수를 타입으로 만들 수 있다.
-용도
 호출하는 주체가 함수 내부 내용이 어떤 건지 아예 몰라도 함수를 호출할 수 있다. 실제로 쓰이는 곳은 굉장히 많은데, 아는 것중에 IP 패킷 처리를 예로 들겠다. IP패킷이 들어오면 먼저 IP헤더를 떼고 내용을 보는데 내용물이 TCP인지 UDP인지 다음에 패킷을 받는 놈은 모른다. 따라서 어떤 식으로 처리를 할지 원래는 두 함수를 만들어야 되는데, 처리하는 함수만 따로 만들어서 건네주고 헤더를 봐서 처리하는 함수를 같이 다음 단계 함수에게 건네주면 알아서 처리를 해 줄 것이다. 이런 식으로 내용물을 모르더라도 처리를 할 수 있게 만드는 데 유용하다.
16장 동적 메모리 할당.
 - int a[d];이런식으로 배열을 정의하고 싶지 않니?
int *p = (int*)malloc(sizeof(int)*d);
 int *p = new int[d];이렇게 하면 된다구!
할당을 했으면 해제를 해 줘야지. delete[] p;하면 된다. 사용하는 방식은 배열이랑 완전히 같다. new와 delete가 짝이고 new[]와 delete[]가 짝이다. delete를 제대로 안해주면 메모리 누수가 난다.
int **p =new int[d][e];
for(int i = 0;i<d;i++)
{
	delete[]p[i];
}
p= NULL;
-주의사항
 NULL은 막 해제해도 된다, delete한 데에 또 delete하면 안된다. 보통은 해제한 뒤에 NULL을 넣어서 실수를 방지한다. 
함수 내부에서 할당한 메모리가 함수 끝났다고 지워지지는 않는다. 배열이나 string을 새로 만들어서 리턴할 수 있다는 이야기.

과제
스택

void Push(int)
int Pop()
bool Empty()
int Count()

private:
 자료형

2가지 구현
기본 -링크드 리스트
앞에만 넣음. 헤드를 푸시 팝

추가 -원형 배열
헤드와 테일. 배열의 인덱스

++하노이의 탑