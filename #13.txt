#13
28장 네임스페이스
비슷한 클래스, 비슷한 코드를 묶어 놓는 방법
다른 네임스페이스 안에서 정의된 클래스, 함수들은 이름과 시그니쳐가 같아도 상관없다.
실제 사용할 때 네임스페이스 내부로 들어가서 써야 하기 때문.
어떤 클래스가 네임스페이스 내부에 있다면 멤버 함수도 전부 네임스페이스 내부에 있어야 하며,
그걸 외부에서 사용하기 위해서는 스코프 연산자 :: 를 써서 어떤 네임스페이스의 클래스인가, 함수인가를 표시해주면서 사용해야 한다.
설령 모든 네임스페이스 중 한 네임스페이스에만 있는 클래스라도 그냥 가져다 쓰려고 하면 오류가 난다.
using namespace std
처음 헬로월드 할 때 썼던 코드가 여기서 나온다. 이미 말했지만 std네임스페이스에 cin,cout이 있고 그걸 직접 표시하지 않고 그냥 쓰기 위해서
있는 코드. using은 두 개 이상 사용할 수 있으나 이렇게 쓰지 않기를 권장한다. 제일 보편적인 방법은 std만 using을 쓰는 것.
네임스페이스 내부의 함수나 변수 하나만 using을 할 수도 있다.
전역 변수를 쓰고 싶으면 ::앞에 아무것도 안 붙이고 쓰면 된다.
다른 소스 파일끼리도 네임스페이스를 공유할 수 있다. 이를테면 namespace car안에 클래스 Car, Engine, Wheel등을 만들어서 사용할 때는 car를 가져다 쓴다.
당연히 헤더에 있는 클래스 선언, cpp에 있는 클래스 정의 다 네임스페이스 블록{} 안에 들어있어야 한다.
네임스페이스의 이름을 안 적으면 다른 파일에서 extern으로 쓸 수 없다. 내 파일에서는 앞에 ::없이 그냥 쓸 수 있다.
네임스페이스 안에 네임스페이스를 또 넣을 수 있다.
변수 선언처럼 네임스페이스에 별명을 붙여줄 수 있다. Data::User::Free라고 있으면
namespace dd = Data:User:Free;하면 dd::해서 저걸 넣은 것처럼 쓸 수 있다.

29장 템플릿
템플릿 클래스
template<typename T>
class Foo{
};
typename은 class로 써도 된다. 꼴리는 대로 쓰도록 한다.
여기서 타입을 넣으면 실제로 그 타입을 넣어서 사용하는 클래스가 컴파일 도중에 생기며, 그래서 많으면 컴파일이 오래 걸린다.
템플릿 매개변수(저 위에서는 typename T)는 몇 개씩 쓸 수 있다.
template<typename A,typename B, int N>뭐 이런 식. 클래스 만들 때는 <int,float,30>이런 식으로 만들게 된다.
템플릿 함수
템플릿 클래스가 아닌 클래스의 멤버 함수도 템플릿 함수로 만들 수 있다.
template<typename T>
T max(T a, T b) 뭐 이런 느낌.
템플릿 함수까지 헤더 파일에 있는 게 좋다는듯.

STL
템플릿으로 만들어진 라이브러리. 자료구조와 알고리즘으로 나눠져 있으며 알고리즘을 타입이나 자료구조와는 상관없이 사용할 수 있다.
물론 이런 알고리즘을 제대로 쓰기 위해서는 연산자 오버로딩이 필요.
STL컨테이너
list(더블 링크드 리스트) vector(동적배열) queue,map(탐색트리)등이 있다.
STL알고리즘
sort, find, reverse, replace, binary search등을 사용할 수 있다. 표를 보도록 합시다. 함수마다 어느정도 옵션들도 넣을 수 있음. 오름차순 내림차순 정렬같은것도 가능.
제너릭 프로그래밍
정보 타입과 정보 처리하는 부분을 분리. 분리함으로써 연관성을 제거해서 다른 타입을 넣더라도 같은 동작을 하게 하는 것이다.
재사용성과 확장성이 증가된다.

30장 C++스타일 입출력
stream
모르고 일단 썼을텐데 개념은 이렇다.
파일, 콘솔, 네트워크에서 모두 스트림을 사용하며 스트림이라는 건 바이트 스트림, 즉 1바이트씩 있는 데이터의 한 덩어리이다.
874p 상속계층도를 보도록 하자.
버퍼링. 어느 정도 저장소를 만들어서 일정 크기가 되면 빼내는 것.
버퍼를 뽑아내는걸 flush한다고 하는데, cout<<"      "<<flush;이런 식으로 가능하다.
setf() 로 입출력 형식을 바꿀 수 있다. 몇 진법으로 쓴다거나 진법을 표시한다거나 소숫점 몇째자리까지 표현한다거나 하는 표현방식을 바꿀 수 있다.
인자 하나, 두개인 버전이 있다. 물론 사용법이 다르다. 876p에 잘 써있다. 
비트 마스크
비트단위로 되어 있는 변수(주로 옵션에 사용)를 |나 &를 써서 어떤 값이 들어있는지를 검사해서 쓰는 방식.
조종자
setf를 안 쓰고 그냥 예약어를 써서 넣을 수 있다. 880p
스트림의 상태
good() eof(), fail(), bad()같은 함수로 스트림이 제대로 동작하는지를 알 수 있다. 파일 입출력에서 eof를 자주 쓰므로 기억해 둘 것.
정수를 입력받으려고 했는데 문자열을 넣었을 때 상태가 fail이 되는데 이런 상태는 clear()를 한 뒤에 써야 한다.
clear만 하면 안에 데이터가 남아 있으므로 ignore을 같이 써야 한다고 한다.
파일 입출력
ofstream, ifstream 파일 스트림으로 open("파일명")해서 파일을 읽고 쓴다. open은 매개변수를 두 개 받을 수 있어서 뒤에 비트마스크로 옵션을 넣을 수 있다. ios_base::in같이 네임스페이스에
정의된 옵션을 쓴다. in이나 out으로 해서 파일을 쓰기 위해 여나 읽기 위해 여나 명확히 제시해 줄 수 있다.
다쓰면 close를 하면 파일이 닫힌다. 
c스타일 입출력
직접 쓰지 않겠지만 코드를 볼 일이 있으므로 알아두면 좋다.
stdio.h ==cstdio. 같은 식으로 c일 때 헤더파일들은 뒤에 h를 빼고 c를 앞에 붙여서 인클루드할 수 있다. 둘은 완전히 똑같다.
printf("%d", a) 뭐 이런 식으로 int를 출력할 수 있다.scanf("%d %d %d", &a,&b,&c)같은 식으로 입력할 수 있다. 다른 타입이면 %뒤에 문자가 달라진다.
scanf를 하면 abc의 내용이 달라져야 하므로 call by reference를 한다.

끝! 폐정!

