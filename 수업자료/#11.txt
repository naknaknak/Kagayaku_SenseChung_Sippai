#11
24장 예외 처리
프로그램이 에러 없이 컴파일된다 - > 불안함
프로그램에서 에러가 나온다 - > 화가 남
같은 거랑은 약간 다른 문제. 보통 버그는 로직이 잘못된 경우를 말하는데 이건 로직이 아니라 컴퓨터 상태가 안 좋은 경우의 예외들을 말함.
메모리가 꽉찼다거나 하드 용량이 모자라다거나 하는 부분. 혹은 범위를 벗어난 값이 입력되거나 할 때가 예외인 것.
C++은 심심하면 프로그램이 터지므로 그러려니 하고 얌전히 예외처리를 하도록 하자.
그럼 예외처리를 어떻게 하느냐? 전통적 방식 - 함수 리턴 값
원래는 리턴을 할 필요가 없는 void를 쓰던 함수의 리턴 값을 bool로 고치고, 정상 T/오동작 F이런 식으로 반환을 시킨 뒤에
함수의 반환값을 테스트해서 어떤 오류가 났는지 판정한다. 양수 int 를 반환하는 함수의 경우 -1같은 식으로 정한다.
문제점 : 리턴값을 쓰는 함수에는 그대로 쓸 수 없고 형태를 고쳐야 한다. 코드를 읽기가 어려워진다.
해결책
try catch throw구문.
try{}
catch(type){} 이 두 개는 쌍으로 다닌다. try블록 안에서 던져진 예외를 catch가 받아가는 것.
throw 객체, 상수 등. 이걸로 던지면 catch가 자기한테 맞는 타입이면 받는다.
예외가 던져지면 함수는 바로 종료된다. 어떤 면에서는 return과 비슷하다고 볼 수 있다.
catch로 받은 예외는 함수의 매개변수처럼 그 블럭({}) 안에서 쓸 수 있다.
객체로 던지는 예외
보통 예외를 던지는 객체, 설명 같은 걸 담은 객체를 만들어서 던지는데 사용함. 706p 24-5예제 참조.
생성자에 this넣어서 던짐.
다형성과 조합
부모 하나 만들어 두면 자식들 객체를 다 받을 수 있다. 물론 객체를 받은 다음 판별하는 과정은 받은 곳에서 따로 만들어야 함.
예외 던지면 반드시 잡아야 됨.
예외 받은 놈이 다시 던질 수 있음. 그런 경우는 그냥throw; 하면 된다. 나는 했지만 딴애한테도 예외를 가르쳐줘야 될 상황이 됐을 경우.
try하나에 여러 catch가 물릴 수 있음. 물론 타입은 다 달라야 하고, 맨 위에서 상속된 최상위 클래스를 받으면 아래 catch들은 다 쓸모없게 된다.
위부터 판정을 하기 때문.
객체를 받는 함수는 보통 레퍼런스로 받는데, 이는 deep copy를 피하기 위해서. 예외도 예외는 아니다.
포인터로 안 받는 이유는 메모리 할당해제를 해줘야 되기 때문.
함수가 끝나기 전에 보통 예외가 발생하는데, 이러면 할당했던 메모리나 자원들을 해제 못 할 경우가 발생할 수 있다. 그래서 예외처리를 할 때는
할당했던 메모리를 해제하는 부분을 예외 때문에 무시하지 않나 주의해야 한다.
스마트 포인터
소멸자에서 메모리를 해제하는 객체. c++에 정의도 돼 있다. auto_ptr이다.
생성자에서 동적 할당을 한 뒤 예외가 발생하면 바로 거기서 catch로 잡아서 delete해줘야 한다.
소멸자에서는 밖으로 예외를 못 던지게 해야 한다. 밖으로 던지면 프로그램 에러남.
auto_ptr서는 new로 만든 것밖에 관리할 수 없다. 모자라다 싶으면 boost에서 받아서 써보라는듯.
new관련해서는 bad_alloc예외가 나오므로 알아두자.
