#9
20장 객체지향 프로그래밍

객체 - 데이터+ 데이터를 처리하는 함수
private, public으로 대표되는 접근 권한을 제한(실수방지용)
재사용성
헤더 파일 같은 타입 정보를 인터페이스라고 하고, 이건 객체 내부 구현이 겉으로 드러나 있지 않기 때문에 가능(캡슐화라고 부른다). 이런 인터페이스만 맞게 유지하면 구현이 바뀌더라도 그 객체를 사용하는 사람들은 아무 생각없이 쓸 수 있게 됨.

-클래스와 객체
클래스는 추상적인 정의. 이 객체에는 무슨 함수가 있고 무슨 변수가 있어야 한다는 것. 
객체는 실제로 메모리에 클래스가 정의된 모습. 이 클래스는 사용자 정의 타입이 된다.
인스턴스는 좀 더 넓은 개념인데, 메모리에 있는 모든 변수나 함수들에 대해서 접근할 수 있는 걸 인스턴스라고 하고 클래스의 인스턴스라고 하면 그게 여기서 말하는 객체가 된다.
-정보 은닉, 캡슐화
내부 구현을 몰라야됨! 왜냐면 알면 건드리고싶어지니까! 거기에 맞춘 방법을 쓰고 싶어지니까! 그럼 내부 구현이 바뀌었을 때 다 고쳐야되니까! 이걸 안보이게하는 걸 캡슐화라고 한다.
-상속, 다형성
아버지... 클래스를 계승하는 중입니다... 클래스는 데이터와 함수로 나눠지지만, 이건 그냥 세상에 있는 개념을 주워다 쓴 거에 불과함. 부모 클래스에서 기능이나 변수를 추가해야 할 때 상속을 하고, 도형으로 보통 설명한다. 도형 클래스 자식으로 삼각형-사각형-원 등이 있을 수 있고, 이 도형들을 실제 그리는 함수는 도형마다 달라야 한다. 그리고 도형들의 자료(꼭지점 등)이 다 달라야 하고, 그렇지만 도형이라는 속성에서 공통적으로 있어야 하는 데이터(위치, 크기 등)은 공유하는 것이다. 상속을 해서 어떤 변수나 함수를 추가하는 행위 자체는 클래스가 커버할 수 있는 범위를 줄이는 행위이다. 하나로는 표현할 수 없는 예외를 많이 정의하고 싶다. 혹은 부분집합들을 정의하고 싶다고 할 때 상속을 쓰면 된다.  도형 말고는 file system으로도 설명할 수 있다. NTFS, FAT등은 실제 읽기 쓰기를 할 때 다른 방식으로 쓰지만 우리가 윈도우에서 쓸 때 아무런 불편도 없는 것이 이 상속 덕분이다.
다형성은 위에서 말한 걸 실제로 만든 기능이다. 같은 함수를 자식들이 다르게 썼을 때 프로그램 실행중에 가상함수 테이블을 찾아서 함수를 호출하는 식으로 구현된다.

21장 클래스와 객체의 기본
-멤버 변수
linkedlist의 head나 count보면 알겠지만 어떤 타입이든 들어갈 수 있음.
public멤버 변수로 하면 구조체처럼 linkedlist.count이런 식으로 접근가능.
C++에서는 Get Set함수를 만들어서 멤버 변수들에 접근시킴. LinkedList처럼 이런걸 하지말아야되는 변수들만 있으면 이런 함수를 만들면 안된다.
-변수든 함수든 사용법은 똑같음
list.add()같은 식으로 .을 써서 사용한다. 포인터일 경우 ->를 쓴다.
-객체의 초기화와 대입
객체를 정의하면서 넣어주면 초기화, 중간에 넣어주면 대입이다.
-생성자와 소멸자
생성자에서는 보통 멤버변수, 메모리 초기화 같은 걸 하고 소멸자에서는 할당했던 메모리를 전부 지우는 일을 한다.
p544부터 코드 읽어볼것
생성자는 객체와 이름이 같고 리턴값이 없다. 그냥 함수처럼 인수를 받을 수도 있으며 복사 생성자는 다른 객체에게서 변수들을 받아서 초기화하는 일을 보통 하게 된다. 형식은 코드를 참조할 것. 
Point(int _x, int _y) :  x(_x) y(_y){}이런 식으로 초기화를 할 수 있다. 반드시 초기화해야 되는 const와 &형 변수는 저런 식으로 초기화를 해줄 것. 당연히 저런 변수들이 있으면 생성자가 있어야 한다.
-임시 객체 만들기
p558 코드 볼 것.
-소멸자
객체가 없어질 때 무조건 호출. ~객체명()이다. 리턴타입이 없다. 보통 동적으로 만든 메모리를 해제하는 데 많이 쓴다. 정적인 메모리는 알아서 해제해주기 때문이다.
-deep copy shallow copy
그냥 =쓰면 shallow copy가 되고, 이렇게 복사 생성자나 원래 있는 =(대입 연산자)를 쓰기 위해서는 연산자 오버로딩과 복사 생성자를 만들어야 한다. 포인터가 있는 것들은 거의 무조건 shallow copy가 된다고 보면 된다. 배열도 마찬가지. deep copy는 알아서 구현해줘야 한다. 왜 이상하게 동작하냐면 배열이 있는 클래스를 =로 대입했을 때 보통 한 클래스 내부 값이 바뀌면 다른 클래스 배열 내부 값도 바뀌는 걸 원하지는 않을 것이기 때문이다.
-접근 제어
public protected private
protected는 자식이 볼 수 있다. 상속을 하는 클래스는 보통 protected로 쓰고, 상속을 안하면 private을 쓴다고 생각하면 되겠다.  보통 멤버 변수는 모두 protected, 혹은 private을 쓴다. 지나가던 클래스가 바꾸면 안 되기 때문이다.
-접근자
Get Set함수이고, 이 함수들을 통해서 멤버 변수를 바꾸게 되면 자기가 어느 정도 값을 제어해서 넣고 뺄 수 있어서 유용하다.
-static
모든 객체가 공유하는 멤버. 지금까지 나란 객체가 몇 개가 만들어졌는가 하는 카운트를 센다거나 할 때 쓴다. 메타정보를 보관할 때 쓴다고 생각하면 ok. 함수와 변수가 있으며 static변수는 static함수에서만 접근가능하다. static함수는 일반 멤버변수에 접근할 수 없다.
-인라인 함수
length 같은 것. 짧은 함수를 인라인으로 쓰면 코드도 안 늘어나고 함수 호출 오버헤드가 줄어든다. 인라인은 define같은 걸로 함수 호출하면 그 부분을 써놓은 코드로 바꿔준다. 인라인함수는 헤더 파일에 있어야 된다. 물론 컴파일러의 자의적 판단으로 인라인함수를 안 쓸 수도 있다. 별로 신경쓸 필요는 없음
-const함수
내부에서 멤버변수값을 바꾸면 에러가 난다. const함수 내에서 비 const함수를 써도 에러가 난다. 안바뀌는 동작을 보증할 수 없기 때문이다. 함수 뒤에 const를 붙이면 된다. 가능한한 모든 함수를 const 로 만들자.
-멤버 함수에 대한 포인터
typedef void (linkedlist::*fp2)(int);이렇게 쓰면 된다. ::스코프 연산자를 추가해야 그 멤버 함수에 대한 포인터가 된다는 듯.
-static은 그냥 ::없이 쓰면된다
-멤버함수도 그냥 오버로드하면된다
-객체도 배열만들수있다. 원소넣는란에 생성자로 넣어주면 됨.
-new int하는 것처럼 new 객체 이렇게 만들수있음. node만들 때 이미 했을것.
-생성자 소멸자는 new delete할 때 호출됨
-생성자가 private이라도 static함수에서 객체 생성 가능. 싱글턴 패턴에 쓴다.
-객체 내부에서 typedef하면 내부에서만 쓰는 타입을 정의가능
-this 포인터
객체 자신을 가리키는 포인터이다. 멤버 함수에서 다른 멤버 함수를 호출할 때 그냥 쓰지만 this포인터를 써서 호출한다고 생각하면 편하다. static에는 없다.