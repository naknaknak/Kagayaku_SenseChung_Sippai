#12
26장 접근범위와 존속 기간
접근 범위 : private public같이 어디서는 접근가능, 다른데서는 접근 불가 같은 걸 말한다.
지역(local) 변수
{}내부에서 정의한 변수는 내부에서만 접근가능하다.
전역(global)변수
모든 {}외부에서 정의한 변수는 모든 함수, 클래스가 다 사용할 수 있다.
존속 기간은 범위와 비슷하다.
Scope는 어떤 변수를 처음 사용할 때부터 마지막 사용할 때까지를 말한다.
존속 기간은 이 Scope와 똑같은 게 제일 좋으며 이유는 메모리나 저장장치 등이 한정되어 있기 때문이다. 
메모리에서 캐시메모리까지 보면 용량이 매우 작으며, 여기서 Scope를 잘 파악해서 적절히 캐쉬에서 삭제하고 많이 쓰일 것들을 넣는 게 효율적이다.
존속 기간은 일단 지역 변수는 {}사이이며 전역 변수는 프로그램이 끝날 때까지라고 생각하면 된다.
지역 변수와 전역 변수의 초기값
지역변수는 초기화하지 않으면 쓰레기값을 갖는다. 디버그 모드에서 브레이크포인트 걸어서 보면 -INT_MAX비슷한 값이 들어가 있다.
디버그가 아닌 릴리즈 빌드로 하면 진짜로 때마다 값이 바뀔것이다. 
전역변수는 초기화 안해도 초기값은 0이다.
지역변수를 쓸 때 auto키워드를 붙여도 된다.
다른 파일에서 정의한 전역 변수를 쓸 때는 extern을 쓴다. 정의하는 것처럼 타입 변수명 이렇게 쓰면 된다.
함수나 if, for같은 제어문이 아니더라도 아무데나 {}중괄호 블록을 만들 수 있으며 그 블록 안에서 지역변수를 정의해서 쓸 수 있다.
바깥쪽 변수와 같은 이름을 썼을 때는 블록 안의 변수가 더 우선적으로 사용된다.
for(int i = 0;;)같은 식으로 i를 for문 안에서 정의했다면 i는 for문 밖에서는 쓸 수 없다.
static으로 지역 변수를 정의하면 프로그램 끝날 때까지 살아있다. 함수호출 횟수를 세는 데 좋다고 한다.
static전역 변수는 다른 파일에서 접근할 수 없게 된다.
register변수
레지스터에 넣어주세요하는 변수이다. 빨리 해줬으면 좋겠다고 생각한다면 이걸 쓰면 된다. 물론 진짜로 레지스터에 넣을지는 컴파일러와 CPU마음이다.
레지스터가 32개밖에 없으니 당연히 모자랄 수 있다.
extern은 변수와 비슷하게 함수에 대해서도 사용할 수 있고 static을 쓰면 그것도 비슷한 의미가 된다. 다른 파일에서 extern으로 함수를 못 받는다.
.c확장자면 c언어로, cpp확장자면 c++로 컴파일되는데 두 언어에서 함수 저장방식이 다르다. c파일에서 만든 함수를 가져오려면
extern "C" 함수 이렇게 쓰면 원래 쓰던대로 쓸 수 있다.

27장 타입2
연산자 오버로딩
기본타입처럼 클래스나 구조체를 다룰 수 있음.
사칙연산, 대입연산, 관계연산(><!===)같은 것들을 오버로딩 가능하다. 배열 인덱스 연산자인 []도 오버로딩 가능하다.
대충 기호같은 건 다 연산자라고 생각하면 된다. {}같은애 빼고.
연산자도 어쨌든 함수기 때문에 vector operator+(const vector& a); 이런 식으로 돼 있으면 실제 실행할 때 vector a,b; b+a;이렇게 돼 있으면
b.operator+(a)이런 함수가 실제로는 실행되는 것이다.
++연산자도 오버로드 가능하고 operator++()같이 그냥 쓰면 ++a, operator++(int)라고 쓰면 a++이 된다.
+-같은 거 할때 접근자를 만들지 않으면 클래스 +-할 때 접근 권한이 없다고 나오니 접근자(get,set)을 만들어놓도록 하자.
아니면 함수를 friend함수로 만들면 된다.
cout에서 쓰는 <<를 오버로딩할라면 리턴값이 ostream&가 되어야 한다. 이건 원래 bit shift연산자인 <<가 ostream같은 데에서 오버로드되어 있기 때문이며
이걸 리턴해서 도로 주면 그 리턴된 값(cout이든 뭐든) 이 입출력을 행하는 것이다. 리턴을 안 해주면 계속 <<해서 집어넣는 게 불가능하다.
오버로딩할 수 있는 연산자 리스트는 그냥 보도록 하자.
못하는 것
원래 있는 기본타입 연산자 오버로딩, 연산자 우선순위나 계산순서 변경.
웬만하면 계산 결과를 바꾸지는 말도록 하자.

형변환
평소대로 (int)처럼 썼다가 이런데서 에러나면 찾을 수가 없으므로 명시적으로 보여주는 것이 낫다.
const_cast
const, volatile을 뗄 때 쓴다.
reinterpret_cast
포인터를 정수로 바꾼다거나 하는 이상한 변환을 할 때 쓴다.
static_cast 
평범한 형변환
dynamic_cast
평범한 클래스간의 형변환. 전에 했던 자식이 부모되는 경우 등에 씀. 잘못되면 포인터면 NULL, 아니면 bad_cast예외를 던진다.
예외는 <typeinfo>헤더를 인클루드해야 쓸 수 있다는 듯.
RunTime Type Information이게 있어야 dynamic_cast를 쓸 수 있는데 설정에서 켜고 끌 수 있다는 듯.
형변환도 함수다!
정의가 가능하다! 그래서 내가 만든 클래스끼리 형변환이 가능하다.
operator int()같은 식으로 정의해서 쓰면 된다.
이렇게 쓰면 암시적 형변환도 가능한데 명시적으로만 쓰게 하고 싶으면 explicit operator같은 식으로 쓰면 된다.
반대로 원래 있는 타입을 내가 만든 타입으로 형변환하고 싶으면 생성자가 int같은 타입을 받아서 생성하면 된다. 참 쉽죠?
숫자 관련된 클래스들에서는 이런걸 줄창 쓰겠지만 지금 있는 score등에선 그리 쓸 일은 없을 것.