Post#3
생각보다 너무 빨리 끝나서 의문의 내용들을 가르치고 말았음. 어차피 나중에 다 배울 내용이긴 하지만 좀 일렀던 것 같기도 하다. 점심은 먹고 다닙시다.
이번 숙제 끝나면 가와이이하게 UI를 붙여볼까도 생각중. UI에 쓰이는 로직 자체는 PHP와 거의 비슷함.
ex)10개씩 나눈다 같은 방법들이 쓰일 것. 모양이 예뻐지면 의욕이 솟지 않을까? 코드는 좆망이겠지만!

숙제
 숫자랑 과목들 입력받아서 출력해주는 프로그램을 작성. 입력은 과목명, 학점, 전공여부 정도
출력은 평균, 전체 수강학점, 전체 학점 정도로 예상.

알려준 내용들

구조체
 C++에서는 클래스와 내부적으로는 완전히 같다고 한다. 변수, 함수를 묶어서 쓸 수 있음. 하지만 주로 변수들을 묶는 용도로 사용한다. 
struct 구조체명
{
	//내부 변수들
	int score;
};
이런식으로 선언함. 이 시점에서는 형식이 정해져 있고 메모리에 할당되진 않은 것

int a;처럼 구조체명 a;이런 식으로 선언한다.
물론 변수로 다른 구조체도 가질 수 있다. 
.연산자를 사용해서 모든 멤버에 직접적으로 액세스할 수 있다
ex) 구조체명.score = 3;

포인터
선언할때 앞에 *붙이면 포인터.
int* a = nullptr;이런 식으로 선언
내용물을 넣어줄때는
int b =5 ; 
a = &b 이렇게 넣어줌. a의 내용물에 액세스하기 위해서는
cout<<*a; 이런식으로 해주면 되고 주소값을 보려면
cout<<a; 이렇게 해 주면 됨.

new연산자

int* a;
a = new int[10];이런식으로 배열을 만드는 게 가능. 사용법이든 뭐든 배열과 완전히 동일하다.
a = new int;도 가능. 기본 자료형들은 string이외에는 모두 가능하다고 보면 됨.

delete연산자
new했으면 반드시 delete해줘야 한다
a = new int[10];해줬으면
delete[] a;
a = new int;해줬으면
delete a;이렇게 다름.
안해주면 a에 할당해줬던 메모리는 남들이 쓸 수도 없고 아무도 쓰지 않는 메모리가 된다.
이렇게 쓸 수 없는 메모리가 늘어나는 걸 메모리 누수(memory leak)라고 한다.

링크드 리스트(배운 건 Singular)
 struct node{
	int value;
	node* next;
}
struct intLinkedList{
	node* head;
}

이런 구조로 되어있는 걸 링크드 리스트라 함. 
next포인터만 바꾸면 되므로 삭제,삽입이 쉽다. 보통 삭제 삽입이 잦고 액세스는 순서대로 하는 자료들에 사용한다.
더블 링크드 리스트도 있다. 이건 node* prev, node* next를 가지면 된다.
tail->head로 돼있는 circular linked list도 존재.

버퍼링
 과목 갯수를 입력으로 받는데 배열의 원소 개수는 고정이므로 충분한 고정 숫자의 배열을 써서 인덱스를 따로 보관하면서 만들면 될 듯.
이런 식으로 얼마 들어올지 모르는 자료를 충분한 공간을 미리 확보해두고 받는 걸 버퍼링이라고 함.
