#6
13장 복합 타입들
공용체(union)
같은 메모리공간을 공유하는 다른 타입 변수. 메모리공간을 공유하므로 다른 변수에서 고치면 반대쪽도 반영이 된다. 선언방식은 구조체와 비슷하고 메모리에 차지하는 크기는 가장 큰 변수 크기만큼 차지한다. 크기가 다를 경우 앞쪽 메모리만 쓴다. 사실상 거의 볼 일은 없을 것이다.
열거형(enum)
함수 리턴값 같은 한 가지 값에 여러 의미(에러 종류, 무사히 종료 등) 이 담겨있을 때 그걸 그대로 #define 이름 한 것처럼 비슷하게 쓸 수 있다. 기본적으로는 정수값에 이름을 붙이는 형태가 된다. switch case문에서 더 빛을 발한다. 이름에 값을 지정할 수도 있고 지정하지 않을 수도 있다. 정의하면 이것도 한 타입이 된다.
레퍼런스
int i;
int& ref = i; 하면 레퍼런스 값 변할 때 i값도 변한다. 일종의 포인터라고 생각하면 좋다. 대신 초기화가 반드시 되어있어야 하며 포인터 내부 주소값을 바꿀 수 없다. const를 생각하면 얼추 맞을 듯. 물론 const int& ref;도 가능. 이 경우는 값을 바꿀 수 없다.
typedef
typedef const unsigned int * LPCTDWORD; 이렇게 쓴다.
구조체 별명붙이거나 할 때 좀 쓴다. 타입 이름이 달라지면 int나 char에 전혀 다른 의미를 담을 수 있으므로 유용하다.
구조체 비트 필드
구조체를 정의할 때 사용하는 비트 수를 정해줄 수 있다. bitwise연산을 대신해서 쓸 수 있다. 그래봤자 내부적으로는 bitwise연산을 쓰므로 성능적으로는 별로 좋지는 않다. 메모리는 절약할 수 있을지도 모른다. 사용하지 않는 비트를 쓸 때는 이름을 안 쓰면 된다.
구조체도 구조체를 멤버로 가질 수 있다. 참 쉽죠?
다차원 배열
int a[10][2][30]이 배열은 어떤 배열일까요!
포인터의 포인터의 포인터의 포인터의…
int********a; 같은 식으로 쓸 수 있다! 다중배열을 포인터로 만들 때 좀 쓰는 것 같다. char**라고 하면 string* 같은 느낌이므로 자주 나오는 것만 기억해서 겁먹지 말도록 하자.

14장 함수1
함수가 뭐죳?
코드덩어리. 나누는건 자유롭게 나눌 수 있다. main함수 안에 전부 다 들어 있을 수도 있고, 기능별로 나눌 수도 있다. 기능의 기준은 자기 마음대로다.

왜 쓰냐?
프로그램이 길어지면 길어질수록 읽기가 힘듬. 문단 나눈다고 생각해도 되고 띄어쓰기같은거라고 생각해도 된다. 재사용성같은 건 그렇게 많이 안 보는데, 왜냐면 재사용할 만한 건 기본 런타임라이브러리에 거의 다 있기 때문. 

함수 정의
리턴타입 함수이름(입력타입 변수이름,...)같은 형식으로 선언한다. 리턴 타입은 함수가 끝나고 리턴하는 값의 타입이다. 단 한 가지 값만 리턴할 수 있다. 물론 구조체든 클래스든 뭐든지 리턴할 수 있으므로 한가지 값이라고 하기엔 좀 다를지도 모른다.
함수 이름은 함수 이름이다. 짓고싶은대로 쓰면 된다. 입력값(보통 매개변수(parameter)와 인자(argument)라는 두 용어를 쓴다. 나는 매개변수는 정의했을 때 입력값, 인자는 실제로 받는 입력값으로 나눠서 쓴다. 책마다 정의가 다른 모양. 그냥 혼동해서 기억하고 있으면 되겠다)
은 타입과 이름으로 나눠지는데, 입력값을 함수 내부에서 쓰지 않을 경우에는 이름을 안 쓰고 타입만 써도 된다! 
인자는 함수의 로컬 변수다
void swap(int a, int b)
{ 
	int temp=a;
	a=b;
	b=temp;
}하면 값이 안바뀐다. 로컬변수는 함수 실행이 끝나면 없어진다. 

함수는 먼저 형식만 정해놓고 뒤에다 구현해도 된다. 
void swap(int ,int); <-이걸 함수의 프로토타입이라고 함

main()
{ 
 //...
	swap(a,b);
}
void swap(int a, int b)
{ //...
}
이런식으로 쓰면 된다. 보통은 이렇게 main파일에 다 넣지는 않고 클래스를 만들 때 헤더 파일과 cpp파일로 나눠서 쓴다.

call by reference
swap(int*a,int*b) 이런식으로 해야 하는데, 로컬변수든 뭐든 포인터 주소로 접근해서 내부 값을 바꾸면 원래 있던 값도 바뀌기 때문이다. 배열은 대부분 배열의 첫째 주소값으로 접근하기 때문에 내부 값이 잘 바뀐다. 물론 배열 원소 하나만 빼서 넣는다면 당연히 내부값은 안 바뀐다.
swap(int&a,int&b)처럼 쓸 수도 있다. 이런 경우에는 int a,int b 일 때  swap(a,b)처럼 쓴다.

배열도 넣을 수 있다.
void ArrayProcess(int arr[]) 이렇게 호출하면 된다.
const int arr[]같은 식으로도 넣을 수 있다. 이럴 경우에는 내부값을 바꿀 수 없다.
이차원 배열 이상도 넣을 수는 있는데 그냥 이중포인터로 쓰자.
arr[][5]같은 식으로 맨 앞에만 비울 수 있다. 왜나면 arr[][5 ]에서 5개짜리 배열이 한 타입이기 때문.

구조체도 넣을 수 있다.
하지만 구조체 크기만큼 로컬변수를 만들고  복사해야 되기 때문에 그냥 레퍼런스로 받도록 하자.

C런타임 함수
숫자랑 관련된 기능이나 string같은 기능은 대부분 있다. 해당하는 헤더를 찾아서 넣어야 하므로 잘 검색해서 쓰도록 하자. atoi itoa같은 것들도 있다.
