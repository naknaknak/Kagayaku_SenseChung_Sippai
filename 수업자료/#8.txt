#8
17장 문자열
C스타일 문자열 char*
char[] k = “ dd”;;
라고 썼을 때 k[0]은 ‘ ‘ k[1]은 ‘d’ k[2]는 ‘d’ k[3]은 ‘\0’이 된다. 문자열 맨 마지막엔 항상 널문자 \0이 오며, “adfasd”라고 그냥 쓰면 마지막에 널문자 하나가 추가로 들어가게 된다. 널문자가 없다면 문자열에서 기능하는 함수들이 대부분 에러가 나므로 주의하자. 스스로 문자열을 바꾸는 함수를 만들었을 때도 마지막에 널 문자를 넣는 걸 잊으면 안 된다.
문자열 함수들
strlen()길이를 잰다. strcpt()문자열을 복사한다. destination이 앞으로 오는 것에 주의할 것. strcmp()문자열을 비교한다. strcat()문자열 두 개를 붙인다. 동작원리는 책에 그림으로 있으니 한번 읽어볼 것. 
C++스타일 문자열 string
string k = “ dd”;
클래스 안에 위 함수들이 들어있는 것 뿐이다. 메모리할당도 대신 해준다.
k.size()같은 식으로 함수를 호출해서 C때와 같은 작업을 한다. + =같은 것도 해준다.
k.find(d);같은 것도 가능하다. 위의 C스타일 char*로 형식을 받는 함수들은 k.c_str()같은 식으로 넣어주면 된다. 이건 const char*이므로 타입에 주의해야 한다.
cin>>string이렇게 입력을 받을 수 있는데, 이렇게 받으면 띄어쓰기마다 다른 string이 되므로 한 줄씩 받을 때는 getline(cin,string)을 쓰자.
cin.getline(char*,int size)로도 받을 수 있다.
18장 헤더 파일과 구현 파일
헤더 파일은 linked list, stack에서 이미 쓰고 있을 것이다. 이걸 main에 include하면 구현 내용까지 한꺼번에 다 들어간다.
그리고 헤더 파일 include할 때도 순서가 중요한데, windows.h와 stdio.h가 충돌하는 경우가 대표적이다. 이 경우엔 위에서 정의한 내용이 아래서 재정의됐다고 경고가 뜨는데, 기본적으로는 충돌하는 헤더는 한꺼번에 include하지 않는 편이 낫다. 그리고 b.h가 a.h를 include하는데 main파일이 a.h,.b.h를 동시에 include하면 문제가 생긴다. 이를 회피하기 위해 #pragma once를 쓰며, 그렇더라도 이 지시문 하나만 믿지 않는 편이 좋다. pragma는 컴파일러에게 지시하는 지시문이다. 실제로 써보게 되면 감이 올 것이다. pragma once이외에도 ifndef define endif를 쓸 수 있으며, 이는 다른 개발환경에 따라 다른 코드를 적용하는 데도 유용하다. 코드는 p478.
굳이 헤더 파일에 클래스가 있지 않고 함수 프로토타입만 주루룩 쓰는 것도 가능하며, 이 경우에는 전역으로 함수가 선언된 효과가 있다. LinkedList::같은 범위 연산자를 쓸 필요가 없고 모든 클래스나 함수가 이 함수를 사용할 수 있게 된다.
표준 라이브러리 혹은 지정해준 폴더를 include할 때는 <>를 쓴다.<iostream>같은 경우다. 그리고 지금 있는 프로젝트 폴더에 있는 파일을 include 할 때는 “”를 쓴다. “LinkedList.h”같은 식이다. 이 폴더 경로는 상대경로로 자기 있는 폴더에서 \.\..\을 써서 상위경로 하위경로에 액세스 가능하다.

숙제는 19장.



