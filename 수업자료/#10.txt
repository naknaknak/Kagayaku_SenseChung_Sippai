#10
22장 상속과 포함
포함-has a 관계
상속-is a 관계
포함
단순히 객체를 멤버로 사용한다.
객체를 정의했으면 객체도 한 타입이기 때문에 다른 객체가 멤버 변수로 가질 수 있다.
책에서는 2d 사각형이 2d점 2개를 가지고 있게 구현함. top left, bottom right이렇게.
생성자, 소멸자
637p코드. 임시 객체를 생성해서 넘겨줄 수 있다. 이 임시 객체들도 그냥 멤버 변수같이 상위 객체가 삭제될 때 같이 삭제된다.
기본적으로 생성자는 포함하고 있는 객체부터, 소멸자는 포함되어 있는 객체부터 호출된다.
왜 이러는지를 생각해 보면 이해가 갈 것.
상속
문서 저장 클래스 예제- 640p이후의 소스를 실행해서 html한번 만들어 볼 것.
상속은 더 많은 기능이나 멤버를 추가하는 거라고 생각해도 되고, 
객체가 현실 물체를 추상화한 거라는 관점에서는 더 좁은 범위의 물체들을 가리킨다고 생각해도 된다.
동물-인간 같은 식으로 동물 객체를 상속해서 인간이 있고, 인간(혹은 영장류)가 도구를 사용한다거나
하는 기능들이 더 있고 다른 동물을 구현하려면 이 동물 객체, 호흡을 한다거나 움직인다거나 하는 기본적인 기능은 그대로 있고 그 동물만의 특징을
더 추가하면 된다는 것이다. 
컴퓨터 관련해서는 보통 파일 시스템을 예로 든다. 가상 파일 시스템을 상속해서 FAT나 NTFS들이 실제로 read, write를 하고 있다.
여기서 동물, 가상 파일 시스템같이 상속을 하는 클래스를 부모라고 하고
인간, FAT같은 클래스를 자식 클래스라고 한다.
위의 포함 관계와 비슷하게 생성자는 부모 클래스부터 실행되고 소멸자는 자식 클래스부터 실행된다.
타입 변환
부모는 자식이 될 수 없으나 자식은 부모가 될 수 있다. 위의 예를 보면 이해가 갈 것이다. 부모보다 자식이 멤버 함수나 변수가 많고,
부모가 자식이 되고 싶어도 멤버 함수나 변수를 가지고 있지 않으므로 될 수 없다는 것.
=를 사용해 대입하면 암시적으로 형변환이 가능하다.
자식을 부모에 넣은 다음에 다시 자식으로 변환할 때는 명시적으로 타입 변환할 때 쓰는 (타입 이름)을 쓰면 된다. 이는 포인터나 레퍼런스도 똑같다.
UML그림을 그려볼것.
자식이 부모되는걸 업캐스트, 부모가 자식되는걸 다운캐스트라고 한다.
사용법을 모르겠으면 652~655p코드를 읽어볼 것.
private: 은 자식이 쓸 수 없으나 protected: 는 자식이 쓸 수 있다. 상속을 염두에 둔 클래스는 접근 제어 할 때 보통 protected:를 쓴다.
물론 public : 은 아무나 다 쓸 수 있다. C++에서 아무것도 안 쓰면 public:이 된다. 그러나 써주도록 하자.
다중상속
두 가지 객체의 멤버함수 변수를 쓰고 싶을 때 다중 상속을 한다. 하지만 상속 단계가 많아지면 많아질수록 기하급수적으로 복잡해지므로 웬만하면 쓰지 말자.
상급 언어인 JAVA나 C#등에서는 다중 상속이 금지되어 있으며, 굳이 하고 싶다면 인터페이스(구현이 없는 클래스)로는 다중 상속이 가능하게 만들었다.
멤버변수나 함수가 같은 이름이라 충돌할 때는 스코프 연산자::를 써서 어느 쪽 변수나 함수인지를 명시해야 한다.

23장 다형성, 가상 함수
다형성
다형성과 가상 함수가 필요한 경우는 도형이나 위의 파일 시스템, 혹은 네트워크 패킷 처리할 때를 예로 들 수 있다.
도형이든 파일 시스템이든 뭐든 같은 목적을 갖는 함수를 쓰는데 상속받는 클래스들이 다 다른 이름으로 쓴다면 상속하는 메리트가 별로 없어질 것이다.
그래서 내부 구현은 자식 클래스한테 맡겨놓지만, 이 클래스는 이런 기능은 있다는 뜻으로 함수를 선언해 놓는 것이다. 
도형의 경우에는 Draw()같은 함수, 파일 시스템같은 경우는 Read() Write()같은 함수들이 있을 수 있다. 
이런 것들은 클래스를 정의할 때 갖고 있는 기능들이며, 그러나 하위 클래스마다 다 구현이 달라야 한다. 따라서 상위 클래스에서는 구현하지 않거나
구현을 하더라도 하위 클래스에서는 다르게 써야 한다. 이런 걸 위해 있는 키워드가 virtual이다.
위에 써 있는 것처럼 자식 클래스 포인터 타입은 부모 클래스 포인터 타입이 될 수 있다. 그래서 부모 클래스 배열을 하나 만들어놓고
자식 클래스들을 집어넣어 놓으면 안에 어떤 자식 클래스든 다 들어가는 배열이 만들어지며, 이 때 부모 클래스가 가지는 공통적인 함수도 물론 호출할 수 있다.
책에서는 Draw()함수를 예로 들었고, virtual키워드를 사용하지 않은 상태라면 그냥 부모의 Draw가 호출된다.
함수를 선언할 때 virtual로 선언한다면 지금 있는 객체의 타입이 아니라 실제 안에 있는 타입의 함수를 호출하며, 이건 가상 함수 테이블이라는 걸 메모리 객체가 가지고 있어서
그 테이블을 찾아서 어떤 함수를 호출하나 결정하는 것이다. 이 과정은 컴파일 타임이 아닌 런 타임에 일어난다.
소멸자가 있다면 소멸자는 반드시 가상 함수로 만들어야 한다. 왜냐면 타입이 부모 타입이라 가상함수로 안 만들면 부모 타입 소멸자를 호출해 버리기 때문.
이렇게 호출되면 자식이 동적으로 할당했던 메모리가 해제가 안돼서 메모리 누수가 발생할 수 있다.
이런 식으로 객체를 같은 방식으로 다루면서 다른 결과를 내는 게 다형성이라고 할 수 있다.
오버라이딩
순수 가상 함수 vitual 함수 =0; 이렇게 만든다. 구현은 안 해도 되고(=0이 구현 부분이라고 생각해도 되겠다) 대신에 자식 함수는 무조건 구현해야 된다.
순수 가상 함수가 하나라도 있으면 추상 클래스라고 하며, 추상 클래스는 메모리에 만드는 게 불가능하다. 실행불가능한 함수가 있기 때문이다.
추상 클래스의 반댓말로는 콘크리트 클래스가 있다고 한다.
전부 가상 함수 혹은 순수 가상 함수와 멤버 변수들로 이뤄진 클래스를 인터페이스라고도 한다.
오버로딩 오버라이딩
오버로딩은 인자가 다른 같은 이름의 함수를 만드는 것, 오버라이딩은 부모와 인자까지 같고 내용이 다른 함수를 만드는 것이다. 
부모가 오버로딩한 함수를 오버라이딩하면 오버로딩했던 다른 함수는 오버라이딩하지 않으면 쓸 수 없다. 꼭 쓰고 싶으면 ::연산자를 써서 쓸 수는 있다.
생성자를 오버라이드하면 디폴트 생성자가 없어진다. 멘붕하지 말고 얌전히 만들도록 하자.

