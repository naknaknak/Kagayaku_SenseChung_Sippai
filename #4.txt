#4
-숙제
숙제에서 노오력이 느껴진다.
링크드리스트는 마지막에 얘기했듯이 쓰지 않는 편이 더 나았을 것이다.
포인터를 따라가는 구조 자체를 아직 이해를 못 한 것 같음.
배열을 함수 인수로 받는 법-솔루션에 있다.
지금 수준으로는 함수도 배우지는 않았으므로
배열을 정적으로 선언해서 처리하는 방식이 있음. Main함수가 길어지는 단점이 있을 것이다.
나는 솔루션에서 깔끔하게 보이려고 함수를 씀.

9,10장은 거의 다 한 내용이므로 숙제를 보면서 얘기하겠음. 빨리 나간다면 11장까지 갈 수도 있다.

9장 배열
배열은 같은 타입의 원소를 정해진 갯수만큼 모아놓은 자료형이다.
Int score[100];이런 식으로 정의하며, 정의하고 내버려두면 안에 쓰레기값이 가득 차 있게 된다. 디버그 모드로 하면 항상 쓰레기값이 같게 나오지만 그 값을 쓰려는 시도는 하지 말 것.
인덱스는 0부터 시작하고, Score[100], score[101]같이 배열 인덱스 범위를 넘어가면 액세스 바이올레이션이 뜨면서 프로그램이 꺼진다. 도스에서는 막 쓰는 게 가능했던 모양. 이건 컴파일러가 못 잡으므로 배열 쓸 때는 잘 확인해서 쓰자.
초기화는 시작할 때 값을 집어넣는 행위인데, 
int score[3] = {0,3,5}; 이런 식으로 초기화가 가능하다. 이렇게 명시적으로 배열 원소 숫자를 다 써줄 때는
int score[] = {0,3,5};같은 식으로도 배열을 만들 수 있다.
Int score[100] = {0,3,5};이렇게 쓰면 뒤에 3번부터는 전부 0으로 채워진다. 처음 배열 만들때 쓰레기값이 안 들어가게 하려고 0을 넣는 경우가 있다.
Int score[100] = {0};이렇게 하면 전부 0이 들어간다.
배열끼리 대입은 불가능하다.
sizeof연산자를 써서 배열 크기를 알아낼 수 있다. sizeof(score)이렇게 쓰면 바이트 크기가 나온다. int가 4바이트이므로 /4하면 배열 크기를 알 수 있다.
char배열로 구현된 문자열
C에서 문자열, 그냥 아무생각없이 쓰는 string은 내부적으로는 char배열로 구현되어 있다. “abc”라고 하면 ‘a’’b’’c’\0이렇게 네글자가 들어있는것. 마지막 \0은 널 문자라고 하며 이걸 없애면 문자열이 어디서 끝나는지 몰라서 웬만한 문자열 제어함수는 다 폭발한다. 굳이 건드리지는 말 것. 아스키 코드로는 0이다. C에선 아스키 코드든 문자열이든 같이 취급하므로 넣어도 괜찮지만 굳이 뜻이 있는 문자를 뜻이 없는 숫자로 변환할 필요는 없겠다.

10장 구조체
구조체는 유저가 만든 타입이다. 몇 가지 타입을 묶어서 한꺼번에 쓰려는 용도로 사용할 수 있고, .연산자를 통해서 안의 멤버 변수에 접근할 수 있다. 기본적으로 구조체는 대입 연산 이외에는 거의 모든 연산을 못 쓰게 된다. 모르는 타입(문자열 같은)을 가지고 사칙연산을 할 수는 없다. 대입연산을 하면 보통 값을 복사하게 된다. 
초기화도 가능한데
struct Score{
	float score = 4.5f;
	int subjectUnit =3;
}
이렇게 기본값을 넣는 방식이나
Score myScore= {3.0f, 2};같이 만들때 넣어줄 수도 있다.
  이름없는 구조체도 만들 수 있음
struct {
 	float x;
	float y;
} point1 ={30,50}, point2;같이  정의할 수 있다. 이름이 없기 때문에 처음 만든 변수 이외의다른 변수로 만들 수는 없다. 하지만 안쓴다!
