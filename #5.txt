#5
11장 포인터

메모리주소를 가지고 있는 변수
int* a;같은 식으로 선언한다.
a에 주소값을 넣으려면 int b; a=&b이렇게 주소값 연산자를 사용한다.
어떤 타입이든 포인터로 쓸 수 있다. 구조체도 마찬가지.
내부 값에 접근하려면 *a= 3;이런 식으로 쓴다.
포인터는 사실 어떤 값이든 될 수 있는 메모리 주소값이지만 타입을 붙여서 읽는 법을 강제하는 것. 크기가 다른 타입(ex)char, int)도 포인터 크기는 같기 때문에 서로 대입이 가능해 보이지만 이걸 못하게 제한을 둔 것. 
 타입에서도 지나가듯 언급했겠지만 어떤 값이든 될 수 있다는 건 프로그래밍을 할 때는 치명적인 실수를 하기가 쉽다는 뜻이다. 32비트 정수값을 넣어 놓고 32비트를 넣은지 몰라서 같은 주소에 8비트 값을 집어넣으면 남은 24비트까지 쓸 수 없는 값이 된다. 새로 넣은 8비트는 쓸 수도 있겠으나 이런 식으로 잘못된 시스템에서 그 8비트 안에 있는 값을 어떻게 믿을 수 있겠냐는 문제가 발생하게 된다.
void*
어떤 포인터값으로든 변환할 수 있는 값이다. 이 포인터가 가리키는 값은 (보통 포인터 주소 내부에 있는 값을 칭할 때 가리킨다고 표현한다) 어떤 값이든 될 수 있지만 타입이 정해지지 않으면 그 주소부터 몇 바이트를 읽을지를 모르므로 그대로는 사용될 수 없고 항상 다른 포인터 변수로 변환해서 사용해야 한다. 나중에 할 동적 할당을 할 떄 할당된 메모리들이 void*로 나온다.

위의 a,b 예제에서 a=&b를 했다면 *a=3;같이 a가 가리키는 값을 바꾸면 b도 3이 된다. 함수에서 죽어라고 쓸 것이다.

빅 엔디안, 리틀 엔디안
 고오급 언어를 사용할 때는 그다지 신경쓰지 않아도 되지만 C는 약간 고오급과 하급에 발을 걸친 언어기 때문에… 알아두면 개소리할때 나쁘지 않다. 둘 다 데이터를 저장하는 방법인데 0x12345678이라는 데이터가 있을 때 빅 엔디안은 메모리에 그대로 0x12345678로 저장하지만 리틀 엔디안은 0x78 0x56 0x34 0x12로 거꾸로 자리잡고 있다. 인텔이 써서 이런 뭣같은 방식이 정착됐는데, 아마 초기 하드웨어 한계 때문이었던 걸로 기억한다. 그런 게 있다는 것만 알아두자. 기본적으로는 신경안써도 C컴파일러가 알아서 바꿔준다.

NULL
줬던 예제 솔루션에서 nullptr이라는 예약어를 봤을 텐데 이건 C++11부터 생긴 표준이다. 예전에는 NULL을 썼고 이게 #define NULL 0 으로 돼있다. 왜 0인지는 전에 두번정도 얘기한거같으니 넘어가겠다.
 왜 쓰냐면 포인터가 아무것도 가리키지 않을 때 예외처리용으로 쓴다. 거의 모든 코드가 ‘안 쓰는 포인터는 NULL이 들어 있을 것’을 전제로 짜여 있기 때문에 포인터 다 쓰면 주의해서 넣어주자.

const
const int a;라고 하면 a의 값을 바꿀 수 없다. 이건 컴파일할때 검사해준다.
Const int* a;라고 하면 *a가 const int 타입인 것이다. a내부의 값을 바꿀 수 없다. a=&b; a=&c같이 a가 가리키는 변수는 바꿀 수 있다.
Int* const a; 라고 하면 안에 있는 값은 바꿔도 되는데 a의 주소값을 바꿀 수 없다.
Const int*const a;라고 하면 둘 다 못바꾼다.


12장 포인터와 배열
 
int array[10];
int* p = &array[5];
5번 원소를 p가 가리키고 있다. 애초에 배열은 원소 이름 정하기 귀찮고 모아서 선언하려고 만든 거라서 그냥 변수와 거의 비슷하게 쓸 수 있다.
여기서 p++;하면 p는 6번 원소를 가리킨다. 이건 주소값에 타입 크기만큼 알아서 더해주기 때문이다.
포인터는 덧셈 뺄셈은 가능한데 곱하기 나누기는 안되는데, 이는 위처럼 배열 연산을 할 때 더하기 빼기가 쓰이기 때문이고 곱하기를 하게 되면 이상한 주소로 날아가게 되므로 전혀 쓸모가 없기 때문이다.
 위에서 array는 &array[0]과 완전히 똑같이 쓰인다. 물론 주소값이긴 하지만 array=&b이런 식으로는 대입할 수 없다.
위 예제에서 p = array;한 뒤에 (*p)[3]이라고 하면 array[3]이라고 쓰는 것과 완전히 같다. 이건 특별한 이유가 있는 건 아니지만 그렇게 만들었기 때문이다. 웬만하면 쓰지 않는 편이 좋다. 얌전히int I; 해서 인덱스를 사용하자.
 배열 선언은 완전히 변수 선언과 같은 것이므로 구조체가 배열을 가질 수 있다. 책을 봅시다.
구조체 배열도 만들 수 있고 포인터로 쓸 수 있다. 링크드 리스트가 이런 방식으로 돼 있다.






 


